//! **proof module**
//!
//! This module implements the generation and verification of Zero Knowledge Proofs (ZKPs), using the Fiat-Shamir transform to convert interactive proofs to non-interactive ones.
//!
//! Proofs are used to verify the relationship between sliced, blinded random numbers and promises to ensure security during secret sharing.

use crate::hash_adapter::Blake3Adapter;
use crate::utils::ANOTHER_POINT;
use curve25519_dalek::constants::RISTRETTO_BASEPOINT_POINT;
use curve25519_dalek::{RistrettoPoint, Scalar};

/// zero-knowledge proof structure
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone)]
pub struct Proof {
    #[serde(with = "crate::serialization::serialize_ristretto_point_helpers")]
    proof_ristretto_point: RistrettoPoint,
    #[serde(with = "crate::serialization::serialize_scalar_helpers")]
    response_share: Scalar,
    #[serde(with = "crate::serialization::serialize_scalar_helpers")]
    response_random: Scalar,
    #[serde(with = "crate::serialization::serialize_scalar_helpers")]
    challenge: Scalar,
}

/// The challenge value (challenge) is computed and the Fiat-Shamir transform is used to bind the public data to the slice index.
pub fn compute_challenge(
    commitment: &RistrettoPoint,
    proof_ristretto_point: &RistrettoPoint,
    index: usize,
) -> Scalar {
    let mut hasher = Blake3Adapter::new();
    // Input the base point, the commitment, the point generated by the proof, and the slice index all into the hasher
    digest::Update::update(&mut hasher, RISTRETTO_BASEPOINT_POINT.compress().as_bytes());
    digest::Update::update(&mut hasher, ANOTHER_POINT.compress().as_bytes());
    digest::Update::update(&mut hasher, commitment.compress().as_bytes());
    digest::Update::update(&mut hasher, proof_ristretto_point.compress().as_bytes());
    digest::Update::update(&mut hasher, &index.to_le_bytes());
    Scalar::from_hash(hasher)
}

/// Generating zero-knowledge proofs
///
/// # Parameters
///
/// - `share`: slice value
/// - `random`: blinded random number
/// - `index`: slice index
/// - `commitment`: The slice commitment.
///
/// # Return value
///
/// Returns a Proof struct containing all the elements needed for the proof.
pub fn generate_proof(
    share: Scalar,
    random: Scalar,
    index: usize,
    commitment: RistrettoPoint,
) -> Proof {
    use crate::utils::random_scalar;
    let mut local_rng = crate::utils::new_rng();
    let k_share = random_scalar(&mut local_rng);
    let k_random = random_scalar(&mut local_rng);
    let proof_ristretto_point = RISTRETTO_BASEPOINT_POINT * k_share + (*ANOTHER_POINT) * k_random;
    let challenge = compute_challenge(&commitment, &proof_ristretto_point, index);
    Proof {
        proof_ristretto_point,
        response_share: k_share + challenge * share,
        response_random: k_random + challenge * random,
        challenge,
    }
}

/// Validating zero-knowledge proofs
///
/// # Parameters
///
/// - `proof`: the proof to be verified
/// - `commitment`: the commitment corresponding to the proof
/// - `index`: index of the slice
///
/// # Return value
///
/// Returns `true` if the proof is valid, `false` otherwise.
pub fn verify_proof(proof: &Proof, commitment: RistrettoPoint, index: usize) -> bool {
    let computed_challenge = compute_challenge(&commitment, &proof.proof_ristretto_point, index);
    if computed_challenge != proof.challenge {
        return false;
    }
    let lhs =
        RISTRETTO_BASEPOINT_POINT * proof.response_share + (*ANOTHER_POINT) * proof.response_random;
    let rhs = proof.proof_ristretto_point + commitment * proof.challenge;
    lhs == rhs
}
